Theorem p_implies_p : forall P : Prop, P -> P.
Proof.
  intros P.
  intros P_assumed.
  (* The last two statements introduce the variable, and introduce
     the antecedent (P itself) as an assumption. Now we use the
     tactic "assumption" to prove a proposition already assumed
     in our environment surrounding the subgoal: P. *)
  assumption.
Qed.

Check p_implies_p. (* p_implies_p : forall P : Prop, P -> P *)
Print p_implies_p.
(*Prints:   
p_implies_p =
fun (P : Prop) (P_assumed : P) => P_assumed
     : forall P : Prop, P -> P
 *)

(* A function that takes P, the proposition in question, and P_assumed
   of type P (which means it is evidence for P). It simply returns the
   evidence for P. *)

TTTheorem excluded_middle : forall P : Prop, P \/ ~P.

(* As another example, let's look at contrapositives *)
Theorem contra_pos : forall P Q : Prop, (P -> Q) <-> ((~Q) -> (~P)).
Proof.
  intros P Q.
  split.
  (* Splits the logical equivalence, producing two subgoals, 
     one for the implication in either direction. *)

  (* (P -> Q) -> (~Q -> ~P) *)
  intros p_implies_q.
  intros not_Q assumed_P.  
  generalize (p_implies_q assumed_P).
  intros assumed_Q.
  contradiction.
  
  (* (~Q -> ~P) -> (P -> Q) *)
  intros nq_implies_np assumed_P.
  destruct Q as [Q_true | Q_false].
